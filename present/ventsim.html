import React, { useState, useEffect, useRef } from 'react';

// --- Configuration & Constants ---
const PRESETS = {
  'NORMAL': { resL: 5, compL: 50, resR: 5, compR: 50, name: 'Normal' },
  'ARDS': { resL: 10, compL: 20, resR: 10, compR: 20, name: 'ARDS' },
  'COPD': { resL: 20, compL: 60, resR: 20, compR: 60, name: 'COPD' },
  'DUAL': { resL: 5, compL: 50, resR: 20, compR: 20, name: 'Dual-Lung' }
};

const SETTINGS = {
  mode: 'PCV',
  Pinsp: 10,
  PEEP: 5,
  RR: 14,
  Ti: 1.0,
  Pmus: 0
};

const MAX_POINTS = 2000; // ~30 seconds of history

const Main = () => {
  // --- UI State ---
  const [activePresetKey, setActivePresetKey] = useState('NORMAL');
  const [isRunning, setIsRunning] = useState(true);
  const [monitor, setMonitor] = useState({
    ppeak: '--',
    vte: '--',
    mv: '--',
    rr: SETTINGS.RR
  });

  // --- Physics State (Refs for Performance) ---
  // ‡πÉ‡∏ä‡πâ useRef ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏£‡πá‡∏ß‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ React Render ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
  const physics = useRef({
    time: 0,
    cycleTime: 0,
    phase: 'EXP', // 'INS' or 'EXP'
    volL: (SETTINGS.PEEP * 50) / 1000, // Initial Volume (Liters)
    volR: (SETTINGS.PEEP * 50) / 1000,
    paw: SETTINGS.PEEP,
    flow: 0
  });

  const history = useRef({ p: [], f: [], v: [] });
  const loops = useRef({ pv: [], fv: [] });

  // Canvas Refs
  const waveformRef = useRef(null);
  const loopPVRef = useRef(null);
  const loopFVRef = useRef(null);
  const requestRef = useRef();

  // --- Helper: Auto Scale ---
  const getMinMax = (data, type) => {
    if (!data || data.length === 0) return { min: 0, max: 10 };

    let min = Math.min(...data);
    let max = Math.max(...data);
    let range = max - min;
    if (range === 0) range = 10;

    if (type === 'P') { 
        // Pressure: starts at 0, max at least 30
        min = 0; 
        max = Math.max(30, max + range * 0.1); 
    } else if (type === 'V') { 
        // Volume: starts near 0, max at least 500ml
        min = -50; 
        max = Math.max(500, max + range * 0.1); 
    } else if (type === 'F') { 
        // Flow: Symmetric scale
        let absMax = Math.max(Math.abs(min), Math.abs(max));
        absMax = Math.max(60, absMax); // Minimum scale +/- 60
        min = -absMax * 1.1; 
        max = absMax * 1.1;
    }

    return { min, max };
  };

  // --- Physics Engine ---
  const updatePhysics = () => {
    const dt = 0.016; // 60fps
    const state = physics.current;
    const currentPreset = PRESETS[activePresetKey];

    state.time += dt;
    state.cycleTime += dt;

    // 1. Cycle Logic (Time based)
    const cycleDuration = 60 / SETTINGS.RR;
    const expDuration = cycleDuration - SETTINGS.Ti;

    if (state.phase === 'INS' && state.cycleTime >= SETTINGS.Ti) {
      state.phase = 'EXP';
      state.cycleTime = 0;
      loops.current.pv = []; 
      loops.current.fv = []; // Reset loops for new breath
    } else if (state.phase === 'EXP' && state.cycleTime >= expDuration) {
      state.phase = 'INS';
      state.cycleTime = 0;
    }

    // 2. Target Pressure (PCV)
    let targetPaw = SETTINGS.PEEP;
    if (state.phase === 'INS') {
      targetPaw = SETTINGS.PEEP + SETTINGS.Pinsp;
    }

    // 3. Smooth Pressure Rise (RC filter for machine valve)
    state.paw += (targetPaw - state.paw) * 0.15;

    // 4. Equation of Motion & Volume Calculation
    // Palv = Vol / C, Flow = (Paw - Palv) / R
    
    // Left Lung
    const PalvL = (state.volL * 1000) / currentPreset.compL;
    const FlowL = (state.paw - PalvL) / currentPreset.resL; // L/s
    state.volL += FlowL * dt;

    // Right Lung
    const PalvR = (state.volR * 1000) / currentPreset.compR;
    const FlowR = (state.paw - PalvR) / currentPreset.resR; // L/s
    state.volR += FlowR * dt;

    // Total Flow & Volume
    state.flow = FlowL + FlowR;
    const totalVol = (state.volL + state.volR) * 1000; // ml

    // --- Vte Calculation (Corrected) ---
    // Vt = Current Total Volume - Volume held by PEEP
    const volumeAtPEEP = (SETTINGS.PEEP * (currentPreset.compL + currentPreset.compR));
    const relVol = totalVol - volumeAtPEEP;

    // 5. Update History Buffers
    history.current.p.push(state.paw);
    history.current.f.push(state.flow * 60); // Convert to L/min
    history.current.v.push(relVol);

    if (history.current.p.length > MAX_POINTS) {
      history.current.p.shift();
      history.current.f.shift();
      history.current.v.shift();
    }

    // Loop Data (Collect only during relevant phases if needed, or all)
    // Here we collect mainly inspiration + early expiration for clean loops
    if (state.phase === 'INS' || (state.phase === 'EXP' && state.cycleTime < 0.5)) {
        loops.current.pv.push({ x: state.paw, y: relVol });
        loops.current.fv.push({ x: relVol, y: state.flow * 60 });
    }

    // 6. Update Monitors (End of Expiration / Breath cycle logic)
    // Update monitor display slightly after expiration starts to capture Vte
    if (state.phase === 'EXP' && state.cycleTime < dt * 2) {
       setMonitor({
         ppeak: Math.round(state.paw),
         vte: Math.round(relVol),
         mv: ((relVol * SETTINGS.RR) / 1000).toFixed(1),
         rr: SETTINGS.RR
       });
    }
  };

  // --- Rendering ---
  const draw = () => {
    if (isRunning) {
        updatePhysics();
    }

    // Colors
    const colors = { p: '#f7b44e', f: '#4ade80', v: '#4a90e2', grid: '#333', text: '#aaa' };

    // 1. Draw Waveforms
    const wc = waveformRef.current;
    if (wc) {
        const ctx = wc.getContext('2d');
        const w = wc.width;
        const h = wc.height;
        ctx.clearRect(0, 0, w, h);
        
        const zoneH = h / 3;
        
        // Grids
        ctx.strokeStyle = colors.grid; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, zoneH); ctx.lineTo(w, zoneH); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 2*zoneH); ctx.lineTo(w, 2*zoneH); ctx.stroke();

        // Labels & Lines
        const dataMap = [
            { type: 'P', data: history.current.p, color: colors.p, label: 'Paw' },
            { type: 'F', data: history.current.f, color: colors.f, label: 'Flow' },
            { type: 'V', data: history.current.v, color: colors.v, label: 'Vol' }
        ];

        dataMap.forEach((item, idx) => {
            const bounds = getMinMax(item.data, item.type);
            const range = bounds.max - bounds.min;
            const yOffset = idx * zoneH;

            // Draw Label & Scale
            ctx.fillStyle = item.color;
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(item.label, 5, yOffset + 15);
            
            ctx.textAlign = 'right';
            ctx.font = '10px sans-serif';
            ctx.fillText(Math.round(bounds.max), w - 5, yOffset + 15);
            ctx.fillText(Math.round(bounds.min), w - 5, yOffset + zoneH - 5);

            // Plot Line
            ctx.beginPath();
            ctx.strokeStyle = item.color;
            ctx.lineWidth = 2;
            for (let i = 0; i < item.data.length; i++) {
                const x = (i / MAX_POINTS) * w;
                const val = item.data[i];
                const norm = (val - bounds.min) / range;
                const y = yOffset + zoneH - (norm * zoneH); // Invert Y
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        });
    }

    // 2. Draw Loops
    const drawLoopCanvas = (canvas, data, xLabel, yLabel, xType, yType) => {
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);

        const xData = data.map(p => p.x);
        const yData = data.map(p => p.y);
        const xBounds = getMinMax(xData, xType);
        const yBounds = getMinMax(yData, yType);

        // Grid
        ctx.strokeStyle = colors.grid; ctx.lineWidth = 1;
        // Zero Lines logic
        if (yBounds.min < 0 && yBounds.max > 0) {
            let yZero = h - ((0 - yBounds.min) / (yBounds.max - yBounds.min)) * h;
            ctx.beginPath(); ctx.moveTo(0, yZero); ctx.lineTo(w, yZero); ctx.stroke();
        }
        if (xBounds.min < 0 && xBounds.max > 0) {
            let xZero = ((0 - xBounds.min) / (xBounds.max - xBounds.min)) * w;
            ctx.beginPath(); ctx.moveTo(xZero, 0); ctx.lineTo(xZero, h); ctx.stroke();
        }

        // Labels
        ctx.fillStyle = colors.text;
        ctx.textAlign = 'left'; ctx.fillText(yLabel, 5, 12);
        ctx.textAlign = 'right'; ctx.fillText(xLabel, w - 5, h - 5);

        if (data.length < 2) return;

        // Plot
        ctx.beginPath();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        data.forEach((p, i) => {
            const xNorm = (p.x - xBounds.min) / (xBounds.max - xBounds.min);
            const yNorm = (p.y - yBounds.min) / (yBounds.max - yBounds.min);
            const x = xNorm * w;
            const y = h - (yNorm * h);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.stroke();
    };

    drawLoopCanvas(loopPVRef.current, loops.current.pv, 'Pressure (cmH2O)', 'Volume (ml)', 'P', 'V');
    drawLoopCanvas(loopFVRef.current, loops.current.fv, 'Volume (ml)', 'Flow (L/min)', 'V', 'F');
    
    requestRef.current = requestAnimationFrame(draw);
  };

  useEffect(() => {
    requestRef.current = requestAnimationFrame(draw);
    return () => cancelAnimationFrame(requestRef.current);
  }, [isRunning, activePresetKey]); // Re-bind effect when run state changes

  // --- Handlers ---
  const handlePresetChange = (key) => {
    setActivePresetKey(key);
    // Reset volumes to PEEP level of new preset to avoid jump
    const preset = PRESETS[key];
    physics.current.volL = (SETTINGS.PEEP * preset.compL) / 1000;
    physics.current.volR = (SETTINGS.PEEP * preset.compR) / 1000;
    loops.current.pv = [];
    loops.current.fv = [];
  };

  return (
    <div className="container" style={{maxWidth: '900px', margin: '0 auto', background: '#393e46', padding: '30px', borderRadius: '16px', color: '#eee'}}>
      {/* ... Header and other static content ... */}
      
      <div className="sim-container" style={{backgroundColor: '#1e2126', border: '1px solid #555', borderRadius: '8px', padding: '15px', marginTop: '20px'}}>
        <h3 style={{color: '#fff', borderBottom: '1px solid #444', paddingBottom: '10px'}}>
           üíª Live Simulation (‡∏Å‡∏£‡∏≤‡∏ü‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á)
        </h3>
        
        {/* Controls */}
        <div style={{display: 'flex', gap: '10px', marginBottom: '15px', flexWrap: 'wrap'}}>
           <button 
             onClick={() => setIsRunning(!isRunning)}
             style={{
               background: isRunning ? '#393e46' : '#f7b44e',
               color: isRunning ? '#f7b44e' : '#222',
               border: '1px solid #f7b44e',
               padding: '8px 16px', borderRadius: '4px', cursor: 'pointer'
             }}
           >
             {isRunning ? '‚è∏ Pause' : '‚ñ∂ Play'}
           </button>
           
           <div style={{width:'1px', background:'#555', margin:'0 5px'}}></div>

           {Object.keys(PRESETS).map(key => (
             <button
               key={key}
               onClick={() => handlePresetChange(key)}
               style={{
                 background: activePresetKey === key ? '#4a90e2' : '#393e46',
                 color: '#fff',
                 border: '1px solid #4a90e2',
                 padding: '8px 16px', borderRadius: '4px', cursor: 'pointer'
               }}
             >
               {PRESETS[key].name}
             </button>
           ))}
        </div>

        {/* Monitors */}
        <div style={{display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '10px', marginBottom: '10px'}}>
           <MonitorCard label="Ppeak" value={monitor.ppeak} color="#f7b44e" />
           <MonitorCard label="Vte (ml)" value={monitor.vte} color="#4a90e2" />
           <MonitorCard label="MV (L)" value={monitor.mv} color="#4ade80" />
           <MonitorCard label="RR" value={monitor.rr} color="#4a90e2" />
        </div>

        {/* Canvases */}
        <canvas ref={waveformRef} width={800} height={300} style={{width: '100%', background: '#000', borderRadius: '4px', marginBottom: '5px'}} />
        <div style={{display: 'flex', gap: '10px'}}>
           <canvas ref={loopPVRef} width={395} height={200} style={{width: '50%', background: '#000', borderRadius: '4px'}} />
           <canvas ref={loopFVRef} width={395} height={200} style={{width: '50%', background: '#000', borderRadius: '4px'}} />
        </div>
      </div>
      
      {/* ... Content Below ... */}
    </div>
  );
};

// Helper Component for Monitor
const MonitorCard = ({ label, value, color }) => (
  <div style={{background: '#222', padding: '8px', borderRadius: '4px', textAlign: 'center', border: '1px solid #444'}}>
    <span style={{fontSize: '0.8em', color: '#aaa', display: 'block'}}>{label}</span>
    <span style={{fontSize: '1.2em', fontWeight: 'bold', color: color}}>{value}</span>
  </div>
);

export default Main;
